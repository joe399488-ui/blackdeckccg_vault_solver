<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diamond Battleship Solver</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & Babel CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons CDN -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <style>
        /* Custom font import for aesthetics */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* light gray background */
        }
    </style>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        // Helper function to get Lucide icon SVG (since we can't import React components directly)
        const Icon = ({ name, size = 20, className = '' }) => {
            const IconComponent = lucide.icons[name];
            if (!IconComponent) return null;
            return <i dangerouslySetInnerHTML={{ __html: IconComponent.toSvg({ size, class: className }) }} />;
        };

        // --- Constants & Helper Functions ---

        const UNITS = {
            yellow: { name: 'Yellow Diamond', width: 2, height: 1, color: '#fbbf24', shape: '1x2' },
            blue: { name: 'Blue Rod', width: 3, height: 1, color: '#3b82f6', shape: '1x3' },
            green: { name: 'Green Rod', width: 4, height: 1, color: '#22c55e', shape: '1x4' },
            orange: { name: 'Orange Diamond', width: 2, height: 2, color: '#f97316', shape: '2x2' },
            red: { name: 'Red Octagon', width: 3, height: 3, color: '#ef4444', shape: '3x3' }
        };

        const getValidEdges = (unit, orientation) => {
            const w = orientation === 'H' ? unit.width : unit.height;
            const h = orientation === 'H' ? unit.height : unit.width;

            if (w === 1 && h === 1) return ['middle'];

            // 1D Shapes
            if (h === 1) { // Horizontal 1xN
                if (w === 2) return ['left', 'right'];
                if (w === 3) return ['left', 'middle', 'right'];
                if (w === 4) return ['left', 'middle-left', 'middle-right', 'right'];
            }
            if (w === 1) { // Vertical Nx1
                if (h === 2) return ['top', 'bottom'];
                if (h === 3) return ['top', 'middle', 'bottom'];
                if (h === 4) return ['top', 'middle-top', 'middle-bottom', 'bottom'];
            }

            // 2D Shapes
            if (w === 2 && h === 2) {
                return ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
            }
            
            if (w === 3 && h === 3) {
                return [
                    'top-left', 'top', 'top-right',
                    'left', 'middle', 'right',
                    'bottom-left', 'bottom', 'bottom-right'
                ];
            }

            return ['middle'];
        };

        const getOffsetFromEdge = (edge, w, h) => {
            // Helper to find the Top-Left coordinate relative to the hit cell (dr, dc)
            const offsets = {
                // 2x2 Corners
                'top-left': { dr: 0, dc: 0 },
                'top-right': { dr: 0, dc: -(w - 1) },
                'bottom-left': { dr: -(h - 1), dc: 0 },
                'bottom-right': { dr: -(h - 1), dc: -(w - 1) },

                // 3x3 & General
                'top': { dr: 0, dc: -Math.floor(w / 2) },
                'bottom': { dr: -(h - 1), dc: -Math.floor(w / 2) },
                'left': { dr: -Math.floor(h / 2), dc: 0 },
                'right': { dr: -Math.floor(h / 2), dc: -(w - 1) },
                'middle': { dr: -Math.floor(h / 2), dc: -Math.floor(w / 2) },

                // 1x4 Specifics
                'middle-left': { dr: 0, dc: -1 }, 
                'middle-right': { dr: 0, dc: -2 }, 
                'middle-top': { dr: -1, dc: 0 },  
                'middle-bottom': { dr: -2, dc: 0 } 
            };

            return offsets[edge] || { dr: 0, dc: 0 };
        };


        // --- Main Component ---

        const { useState, useMemo } = React;

        function DiamondBattleshipSolver() {
            const [gameState, setGameState] = useState('setup'); 
            const [boardHeight, setBoardHeight] = useState(6);
            const [boardWidth, setBoardWidth] = useState(4);
            const [units, setUnits] = useState([]);
            
            const [board, setBoard] = useState([]);
            const [hits, setHits] = useState([]); 
            
            const [selectedCell, setSelectedCell] = useState(null);
            const [hitCount, setHitCount] = useState(0);

            // --- Setup Actions ---

            const addUnit = (color) => {
                setUnits([...units, { id: Date.now(), color, orientation: 'H' }]);
            };

            const removeUnit = (id) => {
                setUnits(units.filter(u => u.id !== id));
            };

            const toggleOrientation = (id) => {
                setUnits(units.map(u => 
                    u.id === id ? { ...u, orientation: u.orientation === 'H' ? 'V' : 'H' } : u
                ));
            };

            const startGame = () => {
                if (units.length === 0) return;
                const newBoard = Array(boardHeight).fill(null).map(() => 
                    Array(boardWidth).fill(null).map(() => ({ revealed: false, isHit: false, color: null, edge: null }))
                );
                setBoard(newBoard);
                setHits([]);
                setHitCount(0);
                setGameState('playing');
                setSelectedCell(null);
            };

            const resetGame = () => {
                setGameState('setup');
                setUnits([]);
                setBoard([]);
                setHits([]);
                setHitCount(0);
            };

            // --- Solver Logic ---

            const discoveredUnits = useMemo(() => {
                if (gameState !== 'playing') return [];
                
                const discovered = [];
                const usedHits = new Set(); 
                
                const remainingUnits = [...units];

                // 1. Edge-based Discovery (Strong)
                hits.forEach(hit => {
                    if (usedHits.has(`${hit.r},${hit.c}`)) return;
                    if (!hit.edge || hit.edge === 'middle') return; 

                    const unitIndex = remainingUnits.findIndex(u => u.color === hit.color);
                    if (unitIndex === -1) return;
                    const unit = remainingUnits[unitIndex];

                    const unitDef = UNITS[unit.color];
                    const w = unit.orientation === 'H' ? unitDef.width : unitDef.height;
                    const h = unit.orientation === 'H' ? unitDef.height : unitDef.width;

                    const offset = getOffsetFromEdge(hit.edge, w, h);
                    const topLeftR = hit.r + offset.dr;
                    const topLeftC = hit.c + offset.dc;

                    // Validate placement
                    let matches = true;
                    const unitHitKeys = [];

                    for(let r = 0; r < h; r++) {
                        for(let c = 0; c < w; c++) {
                            const checkR = topLeftR + r;
                            const checkC = topLeftC + c;
                            
                            if (checkR < 0 || checkR >= boardHeight || checkC < 0 || checkC >= boardWidth) {
                                matches = false; break;
                            }
                            
                            const cell = board[checkR][checkC];
                            if (!cell.revealed || !cell.isHit || cell.color !== unit.color) {
                                matches = false; break;
                            }
                            unitHitKeys.push(`${checkR},${checkC}`);
                        }
                        if(!matches) break;
                    }

                    if (matches) {
                        discovered.push({ ...unit, discovered: true, location: { r: topLeftR, c: topLeftC } });
                        unitHitKeys.forEach(k => usedHits.add(k));
                        remainingUnits.splice(unitIndex, 1); 
                    }
                });

                // 2. Simple Block Discovery (Weak/Fill)
                for (let i = 0; i < remainingUnits.length; i++) {
                    const unit = remainingUnits[i];
                    const unitDef = UNITS[unit.color];
                    const w = unit.orientation === 'H' ? unitDef.width : unitDef.height;
                    const h = unit.orientation === 'H' ? unitDef.height : unitDef.width;
                    
                    for(let r=0; r <= boardHeight - h; r++) {
                        for(let c=0; c <= boardWidth - w; c++) {
                            let allHits = true;
                            const currentKeys = [];
                            for(let dr=0; dr<h; dr++) {
                                for(let dc=0; dc<w; dc++) {
                                    const k = `${r+dr},${c+dc}`;
                                    const cell = board[r+dr][c+dc];
                                    if (usedHits.has(k) || !cell.revealed || !cell.isHit || cell.color !== unit.color) {
                                        allHits = false; break;
                                    }
                                    currentKeys.push(k);
                                }
                                if(!allHits) break;
                            }

                            if(allHits) {
                                discovered.push({ ...unit, discovered: true, location: { r, c } });
                                currentKeys.forEach(k => usedHits.add(k));
                                remainingUnits.splice(i, 1);
                                i--; 
                                break; 
                            }
                        }
                    }
                }

                return discovered;
            }, [board, hits, units, gameState, boardHeight, boardWidth]);

            const probabilities = useMemo(() => {
                if (gameState !== 'playing') return null;

                const probs = Array(boardHeight).fill(0).map(() => Array(boardWidth).fill(0));

                // Create occupied mask (Discovered Units)
                const occupiedMask = new Set();
                discoveredUnits.forEach(u => {
                    const unitDef = UNITS[u.color];
                    const w = u.orientation === 'H' ? unitDef.width : unitDef.height;
                    const h = u.orientation === 'H' ? unitDef.height : unitDef.width;
                    for(let r=0; r<h; r++) {
                        for(let c=0; c<w; c++) {
                            occupiedMask.add(`${u.location.r + r},${u.location.c + c}`);
                        }
                    }
                });

                const discoveredIds = new Set(discoveredUnits.map(u => u.id));
                const remainingUnits = units.filter(u => !discoveredIds.has(u.id));

                remainingUnits.forEach(unit => {
                    const unitDef = UNITS[unit.color];
                    const w = unit.orientation === 'H' ? unitDef.width : unitDef.height;
                    const h = unit.orientation === 'H' ? unitDef.height : unitDef.width;

                    for (let r = 0; r <= boardHeight - h; r++) {
                        for (let c = 0; c <= boardWidth - w; c++) {
                            
                            let valid = true;
                            let hitScore = 0; 
                            let edgeMatchScore = 0; 

                            for (let dr = 0; dr < h; dr++) {
                                for (let dc = 0; dc < w; dc++) {
                                    const cellR = r + dr;
                                    const cellC = c + dc;
                                    const cellKey = `${cellR},${cellC}`;
                                    const cell = board[cellR][cellC];

                                    // Cannot overlap discovered units
                                    if (occupiedMask.has(cellKey)) {
                                        valid = false; break;
                                    }

                                    // Cannot overlap known MISSES
                                    if (cell.revealed && !cell.isHit) {
                                        valid = false; break;
                                    }

                                    // Cannot overlap hits of WRONG color
                                    if (cell.revealed && cell.isHit && cell.color !== null && cell.color !== unit.color) {
                                        valid = false; break;
                                    }

                                    // Overlaps valid hit of SAME color
                                    if (cell.revealed && cell.isHit && cell.color === unit.color) {
                                        hitScore += 1;
                                        
                                        // EDGE CONSISTENCY CHECK
                                        if (cell.edge && cell.edge !== 'middle') {
                                            const expectedOffset = getOffsetFromEdge(cell.edge, w, h);
                                            const expectedTopLeftR = cellR + expectedOffset.dr;
                                            const expectedTopLeftC = cellC + expectedOffset.dc;

                                            if (expectedTopLeftR === r && expectedTopLeftC === c) {
                                                edgeMatchScore += 1000; 
                                            } else {
                                                valid = false; 
                                                break; 
                                            }
                                        }
                                    }
                                }
                                if (!valid) break;
                            }

                            if (valid) {
                                let probabilityValue = 1;
                                if (hitScore > 0) probabilityValue += (hitScore * 100);
                                if (edgeMatchScore > 0) probabilityValue += edgeMatchScore;
                                
                                for (let dr = 0; dr < h; dr++) {
                                    for (let dc = 0; dc < w; dc++) {
                                        if (!board[r + dr][c + dc].revealed) {
                                            probs[r + dr][c + dc] += probabilityValue;
                                        }
                                    }
                                }
                            }
                        }
                    }
                });

                return probs;
            }, [board, hits, units, discoveredUnits, boardHeight, boardWidth]);

            // --- Interaction ---

            const bestMove = useMemo(() => {
                if (!probabilities) return null;
                let max = -1;
                let best = null;
                for(let r=0; r<boardHeight; r++){
                    for(let c=0; c<boardWidth; c++){
                        if(!board[r][c].revealed && probabilities[r][c] > max){
                            max = probabilities[r][c];
                            best = {r,c};
                        }
                    }
                }
                return best;
            }, [probabilities, board]);

            const recordResult = (isHit, color = null, edge = null) => {
                if (!selectedCell) return;
                const { r, c } = selectedCell;
                
                const newBoard = board.map(row => row.map(cell => ({ ...cell })));
                newBoard[r][c] = { revealed: true, isHit, color, edge };
                
                setBoard(newBoard);
                setHitCount(c => c + 1);
                
                if (isHit) {
                    setHits([...hits, { r, c, color, edge }]);
                }
                setSelectedCell(null);
            };

            const handleCellClick = (r, c) => {
                if (board[r][c].revealed) return;
                setSelectedCell({ r, c });
            };

            const activeColors = useMemo(() => [...new Set(units.map(u => u.color))], [units]);

            const getMaxProbability = () => {
                if (!probabilities) return 1;
                let max = 0;
                probabilities.forEach(row => row.forEach(val => { if(val > max) max = val; }));
                return max || 1;
            };
            const maxProb = getMaxProbability();

            const getHeatColor = (val) => {
                if (val === 0) return 'rgb(243, 244, 246)'; 
                const ratio = Math.min(val / (maxProb * 0.8), 1); 
                const r = 255;
                const g = Math.floor(255 * (1 - ratio));
                const b = Math.floor(255 * (1 - ratio));
                return `rgb(${r},${g},${b})`;
            };

            const isGameComplete = units.length > 0 && units.length === discoveredUnits.length;
            const remainingProbability = bestMove && probabilities ? probabilities[bestMove.r][bestMove.c] : 0;
            const shouldShowSuggestion = bestMove && !isGameComplete && remainingProbability > 0;


            if (gameState === 'setup') {
                return (
                    <div className="p-6 max-w-2xl mx-auto bg-white rounded-xl shadow-lg border font-sans my-8">
                        <h1 className="text-2xl font-bold mb-6 text-center text-gray-800">Diamond Solver Setup</h1>
                        
                        <div className="grid grid-cols-2 gap-4 mb-6">
                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-1">Board Height</label>
                                <input type="number" min="4" max="15" value={boardHeight} onChange={e => setBoardHeight(Number(e.target.value))} 
                                    className="w-full border rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500" />
                            </div>
                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-1">Board Width</label>
                                <input type="number" min="4" max="15" value={boardWidth} onChange={e => setBoardWidth(Number(e.target.value))} 
                                    className="w-full border rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500" />
                            </div>
                        </div>

                        <div className="mb-6">
                            <p className="text-sm font-semibold text-gray-700 mb-2">Add Units</p>
                            <div className="flex flex-wrap gap-2">
                                {Object.entries(UNITS).map(([k, u]) => (
                                    <button key={k} onClick={() => addUnit(k)} 
                                        className="px-3 py-2 rounded-lg text-white text-sm font-medium shadow-md hover:opacity-90 transition-opacity transform hover:scale-[1.02]"
                                        style={{ backgroundColor: u.color }}>
                                        + {u.name}
                                    </button>
                                ))}
                            </div>
                        </div>

                        <div className="mb-8">
                            <p className="text-sm font-semibold text-gray-700 mb-2">Active Units ({units.length})</p>
                            {units.length === 0 ? <p className="text-gray-400 text-sm italic p-2 border border-dashed rounded-lg">No units added</p> : 
                            <div className="space-y-2 max-h-60 overflow-y-auto p-2 bg-gray-50 rounded-lg border">
                                {units.map(u => (
                                    <div key={u.id} className="flex items-center justify-between bg-white p-3 rounded-lg shadow-sm">
                                        <div className="flex items-center gap-3">
                                            <div className="w-5 h-5 rounded-full shadow-inner" style={{ backgroundColor: UNITS[u.color].color }}></div>
                                            <span className="text-sm font-medium text-gray-700">{UNITS[u.color].name}</span>
                                        </div>
                                        <div className="flex gap-2 items-center">
                                            <button onClick={() => toggleOrientation(u.id)} 
                                                className="flex items-center gap-1 text-xs bg-blue-100 text-blue-700 px-3 py-1.5 rounded-full hover:bg-blue-200 transition-colors">
                                                <Icon name="RotateCw" size={12} /> {u.orientation === 'H' ? 'Horizontal' : 'Vertical'}
                                            </button>
                                            <button onClick={() => removeUnit(u.id)} 
                                                className="text-red-500 hover:text-red-700 p-1.5 rounded-full hover:bg-red-100 transition-colors">
                                                <Icon name="Trash2" size={16} />
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                            }
                        </div>

                        <button onClick={startGame} disabled={units.length === 0}
                            className="w-full bg-indigo-600 text-white py-3 rounded-lg font-bold text-lg hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed shadow-xl shadow-indigo-200">
                            Start Solving
                        </button>
                    </div>
                );
            }

            return (
                <div className="p-4 max-w-7xl mx-auto font-sans">
                    <div className="flex justify-between items-center mb-6 border-b pb-3">
                        <div>
                            <h1 className="text-3xl font-extrabold text-gray-800">Diamond Battleship Solver</h1>
                            <p className="text-md text-gray-500 mt-1">
                                Progress: <span className="font-semibold">{discoveredUnits.length} / {units.length} units found</span> • Attempts: <span className="font-semibold">{hitCount}</span>
                            </p>
                        </div>
                        <button onClick={resetGame} className="flex items-center gap-2 text-red-600 hover:bg-red-100 px-4 py-2 rounded-lg transition-colors font-medium border border-red-300">
                            <Icon name="RefreshCw" size={18} /> Restart Setup
                        </button>
                    </div>
                    
                    {isGameComplete && (
                        <div className="bg-green-100 border-l-4 border-green-500 text-green-700 p-4 mb-6 rounded-lg shadow-md" role="alert">
                            <p className="font-bold">Game Solved!</p>
                            <p>You found all {units.length} units in {hitCount} attempts. Excellent job!</p>
                        </div>
                    )}


                    <div className="grid grid-cols-1 md:grid-cols-12 gap-8">
                        {/* Board Section */}
                        <div className="md:col-span-8 flex flex-col items-center">
                            <div className="bg-white p-4 rounded-xl shadow-2xl border inline-block overflow-auto">
                                {board.map((row, r) => (
                                    <div key={r} className="flex">
                                        {row.map((cell, c) => {
                                            const prob = probabilities ? probabilities[r][c] : 0;
                                            const isSelected = selectedCell?.r === r && selectedCell?.c === c;
                                            const isSuggested = shouldShowSuggestion && bestMove?.r === r && bestMove?.c === c;
                                            
                                            return (
                                                <div key={c} onClick={() => handleCellClick(r, c)}
                                                    className={`
                                                        w-12 h-12 md:w-14 md:h-14 border border-gray-300 relative transition-all duration-200
                                                        ${cell.revealed ? 'cursor-default' : 'cursor-pointer hover:ring-2 hover:ring-blue-300'}
                                                        ${isSelected ? 'ring-4 ring-indigo-500 z-10' : ''}
                                                    `}
                                                    style={{ 
                                                        backgroundColor: cell.revealed 
                                                            ? (cell.isHit ? (cell.color ? UNITS[cell.color].color : '#4b5563') : '#f3f4f6')
                                                            : getHeatColor(prob)
                                                    }}
                                                >
                                                    {/* Cell Content */}
                                                    {cell.revealed && (
                                                        <div className="absolute inset-0 flex items-center justify-center">
                                                            {cell.isHit ? (
                                                                <div className="w-4 h-4 bg-white rounded-full shadow-md border-2 border-gray-800" />
                                                            ) : (
                                                                <span className="text-gray-500 font-bold text-xl">×</span>
                                                            )}
                                                        </div>
                                                    )}
                                                    
                                                    {/* Suggestion Marker */}
                                                    {!cell.revealed && isSuggested && (
                                                        <div className="absolute inset-0 flex items-center justify-center animate-pulse bg-indigo-200/50">
                                                            <Icon name="Target" className="text-indigo-700 drop-shadow-md" size={36} />
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                ))}
                            </div>
                            
                            {shouldShowSuggestion && (
                                <div className="mt-6 flex items-center gap-3 text-lg text-indigo-800 bg-indigo-100 px-5 py-3 rounded-full font-semibold shadow-md animate-bounce">
                                    <Icon name="Target" size={20} />
                                    Next Target: Row {bestMove.r + 1}, Col {bestMove.c + 1} (Score: {Math.round(remainingProbability)})
                                </div>
                            )}
                        </div>

                        {/* Controls Section */}
                        <div className="md:col-span-4 space-y-6">
                            
                            {/* Action Card */}
                            <div className="bg-white rounded-xl shadow-xl border border-indigo-200 overflow-hidden">
                                <div className="bg-indigo-600 p-4 border-b flex justify-between items-center">
                                    <span className="font-bold text-white text-lg">
                                        {selectedCell ? `Record Move (${selectedCell.r + 1}, ${selectedCell.c + 1})` : "Select a Tile"}
                                    </span>
                                    {selectedCell && (
                                        <button onClick={() => setSelectedCell(null)} className="text-indigo-200 hover:text-white">
                                            <Icon name="X" size={24} />
                                        </button>
                                    )}
                                </div>
                                
                                {selectedCell ? (
                                    <div className="p-4 space-y-4">
                                        <button onClick={() => recordResult(false)}
                                            className="w-full py-3 bg-red-100 hover:bg-red-200 text-red-700 font-bold rounded-lg transition-colors text-base shadow-sm border border-red-300">
                                            MISS / EMPTY
                                        </button>
                                        
                                        <div className="text-center text-gray-500 font-medium">-- OR HIT A UNIT --</div>
                                        
                                        <div className="space-y-3 max-h-[350px] overflow-y-auto pr-2">
                                            {activeColors.map(color => {
                                                const unitDef = UNITS[color];
                                                const relevantUnits = units.filter(u => u.color === color);
                                                const orientations = [...new Set(relevantUnits.map(u => u.orientation))];

                                                return (
                                                    <div key={color} className="border border-gray-200 rounded-lg shadow-sm overflow-hidden">
                                                        <div className="px-3 py-2 text-sm font-semibold flex items-center gap-3 bg-gray-50"
                                                             style={{borderLeft: `5px solid ${unitDef.color}`}}>
                                                            <div className="w-3 h-3 rounded-full" style={{ backgroundColor: unitDef.color }}></div>
                                                            {unitDef.name}
                                                        </div>
                                                        <div className="p-3 space-y-2">
                                                            {orientations.map(orient => {
                                                                const edges = getValidEdges(unitDef, orient);
                                                                return (
                                                                    <div key={orient}>
                                                                        <div className="text-xs text-gray-600 mb-1 font-semibold border-b pb-1">Orientation: {orient === 'H' ? 'Horizontal' : 'Vertical'}</div>
                                                                        <div className="grid grid-cols-4 gap-1.5">
                                                                            {edges.map(edge => (
                                                                                <button key={edge} onClick={() => recordResult(true, color, edge)}
                                                                                    className="px-1 py-1.5 text-xs bg-indigo-50 border border-indigo-300 hover:bg-indigo-200 text-indigo-800 rounded transition-colors capitalize truncate font-medium"
                                                                                    title={edge}>
                                                                                    {edge.replace('middle-', 'mid-')}
                                                                                </button>
                                                                            ))}
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ) : (
                                    <div className="p-6 text-center text-gray-500">
                                        <Icon name="MousePointerClick" size={48} className="mx-auto mb-3 text-gray-300" />
                                        <p className="font-medium">Click an unrevealed tile on the board to record your next move outcome.</p>
                                    </div>
                                )}
                            </div>

                            {/* Unit Status */}
                            <div className="bg-white rounded-xl shadow-xl border p-4">
                                <h3 className="font-bold text-gray-800 mb-3 text-lg uppercase tracking-wider border-b pb-2">Unit Status</h3>
                                <div className="space-y-3">
                                    {units.map((unit) => {
                                        const isFound = discoveredUnits.some(d => d.id === unit.id);
                                        return (
                                            <div key={unit.id} className={`flex items-center gap-3 p-3 rounded-lg border shadow-sm ${isFound ? 'bg-green-50 border-green-300' : 'bg-gray-50 border-gray-200'}`}>
                                                <div className="w-4 h-4 rounded-full shadow-inner" style={{ backgroundColor: UNITS[unit.color].color }}></div>
                                                <div className="flex-1 text-sm">
                                                    <span className={`font-medium ${isFound ? 'text-green-700 line-through' : 'text-gray-700'}`}>
                                                        {UNITS[unit.color].name}
                                                    </span>
                                                    <span className="text-xs text-gray-500 ml-2">({unit.orientation})</span>
                                                </div>
                                                {isFound ? <Icon name="CheckCircle" size={20} className="text-green-600" /> : <Icon name="AlertCircle" size={20} className="text-orange-500" />}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const rootElement = document.getElementById('root');
        // FIX: Use ReactDOM.createRoot for React 18 compatibility
        ReactDOM.createRoot(rootElement).render(<DiamondBattleshipSolver />);
    </script>
</body>
</html>
